# 11. 탐욕 알고리즘 (Greedy Algorithm) 요약 분석

## 1. 그리디 알고리즘의 개요 및 특징
* **정의:** 매 순간 눈앞의 이익만 좇아 해를 구하는 '근시안적' 방법론.
* **핵심 원리:** 현재 시점에서 가장 이득이 되어 보이는 해를 선택하는 행위를 반복함.
* **한계와 가능성:**
    * 대부분의 경우 최적해(Global Optimum)와 거리가 멉니다.
    * 특정 조건(매트로이드 구조 등)을 만족하는 드문 경우에 한해 최적해가 보장됩니다.

---

## 2. 그리디 알고리즘의 실행 구조
알고리즘은 해가 구성될 때까지 다음 3단계를 반복합니다.

**[논리적 흐름도]**
1. **선택 절차 (Selection Procedure)**
    * 현재 상태에서 국소적으로 최적(Best Local Move)인 해답을 선택.
    * $\downarrow$
2. **적절성 검사 (Feasibility Check)**
    * 선택된 해가 문제의 제약 조건(Constraints)을 위반하지 않는지 검사.
    * *조건 만족 시:* 해집합(Solution Set)에 추가.
    * *조건 불만족 시:* 해당 선택을 버림.
    * $\downarrow$
3. **해답 검사 (Solution Check)**
    * 현재까지 구성된 집합이 전체 문제의 해답이 되었는지 확인.
    * *미완료 시:* 1번(선택 절차)으로 복귀하여 반복.
    * *완료 시:* 알고리즘 종료 및 결과 반환.

---

## 3. 그리디 알고리즘의 적용 조건
일반적으로 다음 두 가지 속성을 만족할 때 최적해를 보장하며 잘 동작합니다.

1. **탐욕스러운 선택 조건 (Greedy Choice Property):**
    * 앞의 선택이 이후의 선택에 전혀 영향을 주지 않아야 합니다.
2. **최적 부분 구조 조건 (Optimal Substructure):**
    * 문제에 대한 최종 해결 방법(Global Optimal)이 부분 문제들에 대한 최적 해결 방법(Local Optimal)으로 구성될 수 있어야 합니다.

---

## 4. 알고리즘 로직 상세 분석

### A. 일반적인 그리디 알고리즘 (Algorithm 11-3)
* **입력:** $C$ (원소들의 총 집합).
* **초기화:** 해집합 $S = \emptyset$.
* **처리 루프:**
    ```text
    WHILE (C가 비어있지 않음 AND S가 아직 온전한 해가 아님)
        1. x <- C에서 가장 좋아 보이는 원소 하나 선택 (Selection)
        2. C <- C - {x} (선택된 원소 제거)
        3. IF (S에 x를 더해도 제약조건 만족) THEN (Feasibility)
              S <- S U {x}
    END WHILE
    ```
* **출력:** $S$가 온전한 해라면 $S$ 반환, 아니면 "해 없음" 반환.

### B. 프림(Prim) 알고리즘 (Algorithm 11-2) - MST 탐색
최소 신장 트리(MST)를 구하는 대표적인 그리디 알고리즘입니다.

* **입력:** 그래프 $G=(V, E)$, 시작 정점 $r$.
* **초기화:** 정점 집합 $S = \{r\}$, 간선 집합 $T = \emptyset$.
* **처리 흐름:**
    ```text
    WHILE (S != V) (모든 정점을 방문할 때까지)
        1. 탐색: 집합 S(이미 방문)와 V-S(미방문)를 연결하는 간선들 중
           가중치가 '최소'인 간선 (x, y)를 찾는다. (단, x는 S에, y는 V-S에 속함)
        2. 확장:
           - T <- T U {(x, y)} (최소 간선 추가)
           - S <- S U {y} (새로운 정점 추가)
    END WHILE
    ```

### C. 회의실 배정 문제 (Algorithm 11-7) - 최적해 보장
* **입력:** 회의 집합 $S = \{(s_i, t_i)\}$, $s$:시작, $t$:종료, $n$:회의 수.
* **핵심 로직(정렬):** 회의를 **종료 시간($t_i$)에 대한 오름차순**으로 정렬.
* **처리 흐름:**
    ```text
    1. 초기화: 첫 번째 회의(종료 시간이 가장 빠른 회의)를 T에 추가. last <- 1
    2. 반복 (i <- 2 to n):
        IF (이전 회의 종료시간(t_last) <= 현재 회의 시작시간(s_i))
            - T <- T U {i} (회의 선택)
            - last <- i (마지막 회의 갱신)
    ```

---

## 5. 그리디 알고리즘의 성공과 실패 사례

| 구분 | 사례 | 설명 및 실패 이유 |
| :--- | :--- | :--- |
| **실패 (최적해 X)** | **이진 트리의 최적합 경로** | **[로직]** 분기점에서 당장 값이 큰 노드로 이동.<br>**[반례]** 당장 작은 값을 선택하더라도 그 밑에 매우 큰 값이 있을 경우를 놓침 (예: 15->30->45 선택 vs 15->60->2, 실제론 더 깊은 곳의 값을 못 봄). |
| **실패 (최적해 X)** | **0/1 배낭 문제 (Knapsack)** | **[로직]** 단위 무게당 가치가 높은 순으로 담음.<br>**[반례]** 물건을 쪼갤 수 없는 경우, 빈 공간이 남아 전체 가치 합이 최적이 되지 않음. |
| **실패 (최적해 X)** | **동전 바꾸기 (일반형)** | **[로직]** 큰 단위 동전부터 최대한 사용.<br>**[반례]** 액면가가 배수 관계가 아닐 때 (예: 500, 400, 100원). 800원 생성 시 그리디는 500+100+100+100 (4개)를 내지만, 최적해는 400+400 (2개)임. |
| **성공 (최적해 O)** | **동전 바꾸기 (배수형)** | **[조건]** 동전의 액면이 바로 아래 액면의 배수일 때 (예: 500, 100, 50, 10).<br>이 경우 그리디 알고리즘은 항상 최적해(최소 동전 개수)를 보장함. |
| **성공 (최적해 O)** | **최소 신장 트리 (MST)** | 프림(Prim), 크루스칼(Kruskal) 알고리즘. |
| **성공 (최적해 O)** | **다익스트라(Dijkstra)** | 최단 경로 탐색 알고리즘. |

---

## 6. 매트로이드 (Matroid): 그리디의 이론적 배경
매트로이드 구조를 가진 문제는 그리디 알고리즘으로 **반드시 최적해가 보장**됩니다.

### 정의 (Definition 11-1)
유한 집합 $S$의 부분집합들의 집합 $I$ ($I \subseteq 2^S$)가 다음 두 성질을 만족하면 매트로이드라 합니다.
1. **상속성 (Heredity):** $B \in I$이고 $A \subseteq B$이면, $B$의 부분집합인 $A$도 $I$에 속한다 ($A \in I$).
2. **증강성 (Augmentation):** $A, B \in I$이고 $|A| < |B|$이면, $B$에만 있는 원소 $x$ ($x \in B-A$)를 $A$에 추가해도 $I$에 속한다 ($A \cup \{x\} \in I$).

### 가중치 매트로이드와 그리디 (Algorithm 11-8)
가중치가 있는 매트로이드에서 가중치 합을 최대화하는 문제는 그리디로 해결 가능합니다.
* **로직:**
    1. 전체 원소 $S$를 가중치 내림차순으로 정렬.
    2. 순서대로 원소 $x$를 선택하여 집합 $A$에 추가했을 때 독립성($A \cup \{x\} \in I$)이 유지되면 추가.

### 문제 공간 탐색 관점
* **인접성:** 해 $A$와 $B$가 원소 하나 차이일 때 인접하다고 함.
* **지역 최적해(Local Optima):** 인접한 해들 중 자신보다 좋은 해가 없는 상태.
* **매트로이드의 성질:** 매트로이드 공간에서는 **"지역 최적해가 곧 전역 최적해(Global Optima)"**이며, 최적해를 이루는 봉우리는 단 하나뿐입니다. 따라서 근시안적(Greedy)으로 올라도 정상(최적해)에 도달합니다.

---

## 7. 근사 알고리즘 (Approximation Algorithm)
* **개념:** 최적해를 구하기 어렵거나 불가능한 문제에서, 최적해는 아니지만 그에 '근사한' 해를 구하는 방법.
* **역할:** 그리디 알고리즘은 최적해를 보장하지 못할 때 훌륭한 근사 알고리즘으로 사용되기도 합니다.