# Ch.09 동적 프로그래밍 (Dynamic Programming) 핵심 요약

## 1. 개요 및 배경
**동적 프로그래밍(DP)**은 재귀(Recursion)를 효율적으로 다루는 기법입니다. 큰 문제 안에 닮음꼴의 작은 문제가 포함된 재귀적 성질을 가진 문제에 적용됩니다.

* **재귀적 해법의 양면성:**
    * **장점:** 관계 중심으로 파악하여 문제를 간명하게 볼 수 있음 (예: 퀵 정렬, 병합 정렬, 팩토리얼, DFS).
    * **단점:** 심한 중복 호출이 발생할 경우 성능에 치명적임 (예: 피보나치 수, 행렬 곱셈 최적 순서).
* **DP의 역할:** 재귀적 구현 시 발생하는 **엄청난 중복 호출(비효율)을 제거**하는 방법론입니다.
* **적용 요건:**
    1.  **최적 부분 구조 (Optimal Substructure):** 큰 문제의 최적해가 작은 문제의 최적해를 포함하는 구조.
    2.  **중복 부분 문제 (Overlapping Subproblems):** 재귀적 해결 시 동일한 작은 문제가 반복적으로 호출되는 상황.

---

## 2. 피보나치 수 (Fibonacci Sequence)
가장 기본적인 DP 예제로, $f(n) = f(n-1) + f(n-2)$ 점화식을 가집니다.

### 2.1. 재귀적 접근 (비효율적)
* **알고리즘(Recursive):**
    ```python
    fib(n):
      if (n=1 or n=2) return 1
      else return fib(n-1) + fib(n-2)
    ```
* **문제점:** $fib(7)$을 구하기 위해 $fib(5)$가 여러 번 호출되는 등 지수 함수적인 중복 호출 발생. $n=100$일 경우 계산에 약 3만 5천 년 소요.

### 2.2. 동적 프로그래밍 접근 (효율적)
* **알고리즘(Iterative DP):**
    * **[입력]** 정수 $n$
    * **[처리 과정]**
        1.  배열 $f$의 $f[1], f[2]$를 1로 초기화.
        2.  $i$를 3부터 $n$까지 반복:
            $f[i] \leftarrow f[i-1] + f[i-2]$
    * **[출력]** $f[n]$
    * **특징:** 중복 계산 없이 선형 시간 내 해결.

---

## 3. 행렬 경로 문제 (Matrix Path Problem)
$n \times n$ 행렬의 좌상단에서 우하단까지 이동하며 방문한 칸의 수 합을 최적화하는 문제입니다. (교재의 알고리즘 코드는 **최대 점수**를 구하는 로직으로 작성됨)

* **이동 규칙:** 오른쪽이나 아래쪽으로만 이동 가능 (왼쪽, 위, 대각선 불가).
* **점화식:**
    $$c_{i,j} = m_{i,j} + \max(c_{i, j-1}, c_{i-1, j})$$
    (현재 칸 값 + 왼쪽과 위쪽 중 더 큰 누적값)

### 3.1. 재귀적 해결
* **로직:** 목적지 $(i, j)$에서 역으로 $(i-1, j)$와 $(i, j-1)$을 호출.
* **문제점:** 피보나치와 마찬가지로 경로가 겹치는 지점에서 막대한 중복 호출 발생 ($\Theta(2^n)$).

### 3.2. 동적 프로그래밍 해결
* **[입력]** $n \times n$ 행렬 $m$
* **[처리 과정]**
    1.  계산 결과를 저장할 2차원 배열 $c$ 초기화 (0행, 0열은 경계 처리를 위해 0으로 설정).
    2.  **이중 루프 실행:** $i$ (1 to $n$), $j$ (1 to $n$)
        * $c[i,j] \leftarrow m_{ij} + \max(c[i-1, j], c[i, j-1])$
        * 즉, 위쪽($i-1$)과 왼쪽($j-1$) 중 큰 값을 선택해 현재 값과 더함.
* **[출력]** $c[n, n]$ (우하단 값)
* **수행 시간:** $\Theta(n^2)$ (행렬 크기에 비례).

---

## 4. 돌 놓기 문제 (Pebble Problem)
$3 \times N$ 테이블에 돌을 놓되, 가로/세로로 인접하지 않게 놓으면서 돌이 놓인 곳의 수의 합을 최대화하는 문제입니다.

* **패턴 정의:** 한 열(Column)에 돌을 놓을 수 있는 합법적인 패턴은 4가지가 존재.
    * 패턴 1: 1행에 돌 (상단)
    * 패턴 2: 2행에 돌 (중단)
    * 패턴 3: 3행에 돌 (하단)
    * 패턴 4: 1행, 3행에 돌 (상단, 하단)
* **양립 조건(Compatibility):** 인접한 열(i열과 i-1열) 간에 돌이 맞닿지 않아야 함. (예: 패턴 1은 패턴 1, 2와 양립 불가할 수 있음)

### 4.1. 재귀적 해결
* **함수:** `pebble(i, p)` = $i$열을 패턴 $p$로 놓았을 때의 최대 점수.
* **로직:** 이전 열($i-1$)에 대해 현재 패턴 $p$와 양립 가능한 모든 패턴 $q$를 재귀 호출하여 최댓값을 찾음.
* **문제점:** $n$이 커질수록 중복 호출 비율 급증.

### 4.2. 동적 프로그래밍 해결
* **[입력]** 열의 개수 $n$, 각 칸의 점수 $w$
* **[처리 과정]**
    1.  **초기화:** 1열의 각 패턴별 점수 $peb[1, p]$ 계산.
    2.  **순차 계산:** $i$를 2부터 $n$까지 반복 (각 열에 대해):
        * 각 패턴 $p$ (1~4)에 대해:
            $peb[i, p] \leftarrow \max \{ peb[i-1, q] \} + w[i, p]$
            (단, $q$는 $p$와 양립 가능한 패턴)
    3.  **최종 선택:** $n$열의 4가지 패턴 점수 중 최댓값 반환.
* **수행 시간:** $\Theta(n)$. (외부 루프 $n$회 $\times$ 내부 패턴 루프 상수 횟수).

---

## 5. 행렬 곱셈 순서 문제 (Matrix Chain Multiplication)
$A_1, A_2, ..., A_n$의 행렬을 곱할 때, 연산 횟수를 최소화하는 곱셈 순서(괄호 묶는 법)를 찾는 문제입니다.
* **비용 차이:** $10 \times 100$, $100 \times 5$, $5 \times 50$ 행렬 곱셈 시 순서에 따라 7,500번 vs 75,000번으로 10배 차이 발생.

### 5.1. 재귀적 해결
* **점화식:**
    $$C_{ij} = \min_{i \le k \le j-1} \{ C_{ik} + C_{k+1, j} + p_{i-1}p_k p_j \}$$
    (전체 $i$부터 $j$까지의 곱 비용 = 분할 지점 $k$를 기준으로 왼쪽 비용 + 오른쪽 비용 + 두 결과 행렬의 곱셈 비용)
* **문제점:** 수행 시간이 $\Omega(2^n)$으로 매우 비효율적.

### 5.2. 동적 프로그래밍 해결
* **[입력]** 행렬의 크기 배열 $P$
* **[처리 과정]**
    1.  대각선 $m[i, i] = 0$ 초기화 (행렬 1개 곱셈 비용은 0).
    2.  **대각선 방향 진행:** 부분 문제의 크기 $r$ (1 to $n-1$)을 늘려가며 반복.
    3.  각 구간 시작 $i$와 끝 $j$에 대해 최적 분할 지점 $k$ 탐색:
        $m[i, j] \leftarrow \min_{i \le k < j} \{ m[i, k] + m[k+1, j] + p_{i-1}p_k p_j \}$
* **구조적 특징:** $C_{ij}$ 계산 시점에 필요한 하위 문제($C_{ik}, C_{k+1, j}$)들이 이미 계산되어 있음 (우하향 대각선 채우기 방식).
* **수행 시간:** $\Theta(n^3)$.

---

## 6. 최장 공통 부분 순서 (LCS: Longest Common Subsequence)
두 문자열 $X_m, Y_n$에 공통으로 들어있는 부분 순서 중 가장 긴 것을 찾습니다. (연속될 필요 없음).
* **예:** `<abcbdab>`와 `<bdcaba>`의 LCS는 `<bca>` 등.

### 6.1. 최적 부분 구조
1.  **끝 문자가 같으면 ($x_m = y_n$):** $LCS(m, n) = LCS(m-1, n-1) + 1$
2.  **끝 문자가 다르면 ($x_m \neq y_n$):** $LCS(m, n) = \max(LCS(m, n-1), LCS(m-1, n))$

### 6.2. 동적 프로그래밍 해결
* **[입력]** 문자열 $X, Y$
* **[처리 과정]**
    1.  2차원 배열 $C$의 0행, 0열을 0으로 초기화.
    2.  이중 루프 ($i: 1 \to m, j: 1 \to n$):
        * 문자가 같으면: $C[i, j] \leftarrow C[i-1, j-1] + 1$
        * 문자가 다르면: $C[i, j] \leftarrow \max(C[i-1, j], C[i, j-1])$
* **[출력]** $C[m, n]$
* **수행 시간:** $\Theta(mn)$

---

## 7. 메모하기 (Memoization)
동적 프로그래밍의 일종으로 볼 수 있으나, **Top-down(재귀)** 방식을 유지하면서 중복 계산을 막는 기법입니다.

* **핵심 원리:**
    1.  계산된 값을 저장할 테이블(배열)을 초기화 (보통 0 또는 -1, $-\infty$).
    2.  재귀 함수 진입 시, **이미 계산된 값인지 확인** (`if f[n] != 0`).
    3.  계산된 값이면 저장된 값 반환 (Pruning).
    4.  아니라면 계산 후 **테이블에 저장**하고 반환.
* **장점:** 재귀의 직관적인 로직을 유지하면서도 DP와 동일한 시간 복잡도 효율을 달성.
* **적용 예시:**
    * **피보나치:** 이미 $f[n]$이 0이 아니면 바로 리턴.
    * **행렬 곱셈:** $m[i, j]$가 $\infty$가 아니면 바로 리턴.