# Chapter 10. 그래프 (Graph)

본 문서는 컴퓨터 과학 및 게임 개발의 핵심 자료구조인 그래프의 정의, 표현 방식, 순회(Traversal), 그리고 다양한 최적화 알고리즘(MST, 최단 경로, 위상 정렬 등)을 다룹니다.

---

## 1. 그래프의 개요 및 정의
**학습 목표:** 그래프의 표현법, 탐색 원리(BFS/DFS), 신장 트리, 최단 경로, 위상 정렬, 강연결 요소 이해 및 수행 시간 분석

* **정의:** 현상이나 사물의 관계를 정점(Vertex, Node)과 간선(Edge, Link)으로 표현한 자료구조. $G = (V, E)$
    * **V:** 정점 집합
    * **E:** 간선 집합
* **주요 용어:**
    * **인접 (Adjacent):** 두 정점이 간선으로 연결된 상태
    * **경로 (Path):** 연결된 간선들의 순서열. (단순 경로: 사이클이 없는 경로)
    * **사이클 (Cycle):** 시작 정점으로 되돌아오는 경로.
    * **완전 그래프 (Complete Graph):** 모든 정점 쌍이 연결된 그래프.
    * **가중치 그래프 (Weighted Graph):** 간선에 비용(Cost/Weight)이 할당된 그래프.

---

## 2. 그래프의 표현 (Representation)
컴퓨터 메모리 상에 그래프를 저장하는 방식입니다. $N$은 정점의 수, $E$는 간선의 수입니다.

### A. 인접 행렬 (Adjacency Matrix)
* **구조:** $N \times N$ 2차원 배열(행렬).
* **데이터:**
    * $M[i][j] = 1$ (또는 가중치): 정점 $i$와 $j$ 사이에 간선 존재.
    * $M[i][j] = 0$ (또는 $\infty$): 간선 없음.
* **장단점:** 밀집 그래프(Dense Graph)에 적합하며 간선 존재 여부 확인이 $O(1)$로 빠르나, 메모리 공간이 $O(N^2)$ 필요함.

### B. 인접 리스트 (Adjacency List)
* **구조:** $N$개의 연결 리스트(Linked List) 배열.
* **데이터:** $List[i]$는 정점 $i$에 인접한 모든 정점(및 가중치)을 노드로 연결.
* **장단점:** 희소 그래프(Sparse Graph)에 적합하며 메모리 효율적($O(N+E)$). 간선 확인은 리스트 탐색이 필요함.

### C. 인접 배열 (Adjacency Array)
* **구조:** 연결 리스트 대신 가변 배열(Vector 등)을 사용하여 캐시 효율성(Cache Locality)을 높인 방식. (Unity/Unreal 최적화 시 선호됨)

### D. 인접 해시 테이블 (Adjacency Hash Table)
* **구조:** 인접 정점들을 해시 테이블로 관리하여 탐색 속도 최적화.

---

## 3. 그래프 순회 (Traversal)
모든 정점을 한 번씩 방문하는 알고리즘입니다.

### A. 너비 우선 탐색 (BFS, Breadth-First Search)
* **특징:** 시작 정점에서 가까운 정점부터 층(Level)별로 탐색. 최단 경로(가중치 없을 때) 보장.
* **자료구조:** 큐 (Queue)
* **수행 시간:** $\Theta(|V|+|E|)$
* **알고리즘 흐름도:**
    ```text
    [초기화] 시작 정점 s 방문 표시 -> [Enqueue] 큐에 s 삽입
       |
       v
    [Loop] 큐가 비어있지 않은 동안 반복
       |-> [Dequeue] u 추출
       |-> [Iterate] u의 모든 인접 정점 v에 대해
             |-> [Condition] v가 미방문 상태인가?
                   |-> (Yes) [Mark] v 방문 표시 -> [Enqueue] v 삽입
                   |-> (No) Skip
    ```

### B. 깊이 우선 탐색 (DFS, Depth-First Search)
* **특징:** 시작 정점에서 한 방향으로 갈 수 있는 데까지 깊게 탐색 후 되돌아옴(Backtracking).
* **자료구조:** 스택 (Stack) 또는 재귀 (Recursion)
* **수행 시간:** $\Theta(|V|+|E|)$
* **알고리즘 흐름도:**
    ```text
    [Function] DFS(v)
       |-> [Mark] v 방문 표시 (visited = YES)
       |-> [Iterate] v의 모든 인접 정점 x에 대해
             |-> [Condition] x가 미방문 상태인가?
                   |-> (Yes) [Recursion] DFS(x) 호출
                   |-> (No) Skip
    ```

---

## 4. 최소 신장 트리 (MST, Minimum Spanning Tree)
모든 정점을 포함하면서 간선의 가중치 합이 최소가 되는 트리(사이클 없음).

### A. 프림 알고리즘 (Prim's Algorithm)
* **원리:** 하나의 시작 정점에서 출발하여, 현재 트리에 연결된 간선 중 가장 가중치가 작은 간선을 선택하여 트리를 확장(Greedy).
* **자료구조:** 우선순위 큐 (Priority Queue / Heap)
* **수행 시간:** $O(E \log V)$
* **알고리즘 흐름도:**
    ```text
    [초기화] 시작 정점 r 비용 0, 나머지 무한대 -> [PQ Push] 모든 정점(또는 시작점)
       |
       v
    [Loop] PQ가 빌 때까지 반복
       |-> [ExtractMin] 최소 비용 정점 u 추출 (트리에 포함)
       |-> [Iterate] u의 인접 정점 v에 대해
             |-> [Condition] v가 트리에 없고(Queue에 있고) && 간선(u,v) < v.cost?
                   |-> (Yes) [Update] v.cost = 간선(u,v) 가중치
                   |-> [Update] v.tree = u (부모 설정)
                   |-> [DecreaseKey] PQ 내 v의 키값 갱신
    ```

### B. 크루스칼 알고리즘 (Kruskal's Algorithm)
* **원리:** 모든 간선을 가중치 오름차순으로 정렬한 뒤, 사이클을 형성하지 않는 간선을 순서대로 선택.
* **자료구조:** Union-Find (Disjoint Set)
* **수행 시간:** $O(E \log V)$ (간선 정렬 시간이 지배적)
* **알고리즘 흐름도:**
    ```text
    [초기화] 각 정점을 독립된 집합으로 생성 -> [Sort] 간선들을 가중치 순 정렬
       |
       v
    [Loop] 정렬된 간선 (u, v) 순회 (간선 수 < n-1 일 때까지)
       |-> [Check] Find(u) != Find(v)? (다른 집합인가/사이클 없는가)
             |-> (Yes) [Union] Union(u, v) -> 트리에 간선 추가
             |-> (No) Skip (사이클 발생)
    ```

---

## 5. 위상 정렬 (Topological Sort)
사이클이 없는 유향 그래프(DAG)에서 모든 정점을 간선 방향을 거스르지 않도록 일렬로 나열하는 것. (예: 게임 퀘스트 순서, 빌드 종속성)

### 방법 1: 진입 차수(In-degree) 기반
* **수행 시간:** $\Theta(|V|+|E|)$
* **흐름:**
    1.  진입 차수가 0인 정점들을 모두 큐에 삽입.
    2.  큐에서 정점 $u$를 꺼내 결과 리스트에 추가.
    3.  $u$에서 나가는 간선을 제거(연결된 정점의 진입 차수 감소).
    4.  진입 차수가 0이 된 정점을 큐에 삽입. 반복.

### 방법 2: DFS 기반
* **수행 시간:** $\Theta(|V|+|E|)$
* **흐름:**
    1.  모든 정점에 대해 미방문 시 DFS 수행.
    2.  DFS(v) 함수 종료 직전(더 이상 갈 곳이 없을 때), 정점 $v$를 연결 리스트 **맨 앞**에 삽입.
    3.  최종 리스트가 위상 정렬 결과.

---

## 6. 최단 경로 (Shortest Path)
두 정점 사이의 간선 가중치 합이 최소인 경로.

### A. 다익스트라 (Dijkstra)
* **조건:** 음의 가중치가 없는 그래프. 단일 시작점.
* **수행 시간:** $O(E \log V)$ (Heap 사용 시)
* **알고리즘 흐름도:**
    ```text
    [초기화] 시작점 거리 0, 나머지 무한대 -> [PQ Push] (거리 0, 시작점)
       |
       v
    [Loop] PQ가 빌 때까지
       |-> [Pop] 최단 거리 정점 u 추출
       |-> [Iterate] u의 인접 정점 v에 대해
             |-> [Condition] dist[u] + w(u,v) < dist[v]? (더 짧은 경로인가?)
                   |-> (Yes) [Relax] dist[v] 갱신 -> [PQ Push] (dist[v], v)
    ```

### B. 벨만-포드 (Bellman-Ford)
* **조건:** 음의 가중치 허용. 음의 사이클 감지 가능.
* **수행 시간:** $O(VE)$
* **알고리즘 흐름도:**
    ```text
    [초기화] 시작점 거리 0, 나머지 무한대
       |
    [Loop 1] 정점 수(|V|-1)만큼 반복
       |-> [Loop 2] 모든 간선 (u, v)에 대해
             |-> [Relax] if dist[u] + w < dist[v] then dist[v] 갱신
       |
    [Check] 음의 사이클 확인 (한 번 더 간선 완화 시도 시 값이 변하면 사이클 존재)
    ```

### C. 플로이드-워샬 (Floyd-Warshall)
* **조건:** 모든 정점 쌍 사이의 최단 경로.
* **수행 시간:** $\Theta(V^3)$ (3중 for문)
* **점화식:** $D_{ij}^k = \min(D_{ij}^{k-1}, D_{ik}^{k-1} + D_{kj}^{k-1})$
    * $k$는 거쳐가는 중간 정점의 집합 범위.

### D. DAG의 최단 경로
* **조건:** 사이클이 없는 유향 그래프.
* **수행 시간:** $\Theta(V+E)$ (선형 시간)
* **로직:** 위상 정렬 순서대로 정점을 방문하며 각 정점의 간선을 완화(Relaxation)함.

---

## 7. 강연결 요소 (SCC, Strongly Connected Components)
유향 그래프 내에서 모든 정점이 서로 양방향으로 도달 가능한 최대 부분 그래프.

### 알고리즘 (Kosaraju's Algorithm 변형 등)
1.  **DFS 수행:** 원본 그래프 $G$에 대해 DFS를 수행하며 각 정점의 **완료 시간**을 기록(스택에 push).
2.  **전치 그래프 생성:** $G$의 모든 간선 방향을 뒤집은 $G^R$ 생성.
3.  **DFS 재수행:** 완료 시간이 가장 늦은 정점(스택의 Top)부터 $G^R$에서 DFS 수행.
4.  **추출:** 3번 과정에서 한 번의 DFS로 방문되는 정점들의 집합이 하나의 SCC가 됨.