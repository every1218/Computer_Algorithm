## 06. 검색 트리 (Search Trees) 무손실 요약

본 요약은 제공된 학습 자료의 핵심 이론, 알고리즘 로직, 자료구조의 상태 변화를 구조적으로 분석하여 정리한 내용입니다.

---

### 1. 기본 개념: 레코드와 키

검색 트리 학습을 위해 데이터 저장의 기본 단위를 명확히 정의합니다.

- **레코드 (Record):** 개체(Entity)에 대해 수집된 모든 정보를 포함하는 저장 단위입니다 (예: 사람의 레코드에는 주민번호, 이름, 주소 등이 포함).
    
- **필드 (Field):** 레코드 내에서 각각의 구체적인 정보를 나타내는 부분입니다.
    
- **검색키 (Search Key) / 키 (Key):** 다른 레코드와 중복되지 않아 각 레코드를 식별할 수 있는 대표 필드입니다.
    
- **검색 트리 (Search Tree):** 각 노드가 규칙에 따라 키를 보유하며, 이를 통해 레코드의 위치를 파악할 수 있는 자료구조입니다.
    

---

### 2. 이진 검색 트리 (Binary Search Tree, BST)

#### 2.1. 구조 및 특성

- **노드 구성:** 각 노드는 하나의 키 값을 가지며, 키 값은 모두 달라야 합니다.
    
- **트리 구조:** 최상위에 루트 노드가 존재하며, 각 노드는 최대 2개의 자식 노드를 가집니다.
    
- **대소 관계 규칙 (핵심 로직):** 임의의 노드 키 값은 **왼쪽 서브 트리**의 모든 키 값보다 크고, **오른쪽 서브 트리**의 모든 키 값보다 작아야 합니다.
    
    - 이 규칙에 따라 키 삽입 순서가 트리의 모양과 효율성을 결정합니다 (정렬된 데이터 삽입 시 편향 트리 발생 가능).
        

#### 2.2. 검색 알고리즘 (Search Logic)

검색은 루트에서 시작하여 키 값을 비교하며 재귀적으로 탐색합니다.

- **[입력]:** 트리 루트 노드 t, 검색 키 x
    
- **[처리 과정]:**
    
    1. **종료 조건:** t가 NIL이거나 t.key가 x와 같으면 t를 반환합니다.
        
    2. **왼쪽 탐색:** x<t.key이면 왼쪽 서브 트리(t.left)로 재귀 호출합니다.
        
    3. **오른쪽 탐색:** x>t.key이면 오른쪽 서브 트리(t.right)로 재귀 호출합니다.
        
- **[출력]:** 해당 키를 가진 노드 또는 NIL (실패).
    

#### 2.3. 삽입 알고리즘 (Insertion Logic)

검색 실패 지점이 곧 삽입 위치가 됩니다.

- **[처리 과정]:**
    
    1. 루트에서 시작하여 삽입할 키 x와 현재 노드의 키를 비교하며 내려갑니다.
        
    2. x가 작으면 왼쪽, 크면 오른쪽으로 이동합니다.
        
    3. NIL(자식이 없는 위치)에 도달하면 그 위치의 부모 노드(p)에 새로운 노드 r을 매답니.
        
    4. 새 노드 r의 좌우 자식은 NIL로 설정합니다.
        

#### 2.4. 삭제 알고리즘 (Deletion Logic)

삭제는 대상 노드(r)의 자식 수에 따라 3가지 케이스로 나뉩니다.

- **Case 1: r이 리프 노드인 경우**
    
    - **로직:** 단순히 r을 제거(버림)합니다.
        
- **Case 2: r의 자식 노드가 1개인 경우**
    
    - **로직:** r의 부모가 r의 유일한 자식을 직접 가리키도록 포인터를 연결하고 r을 제거합니다.
        
- **Case 3: r의 자식 노드가 2개인 경우**
    
    - **로직:**
        
        1. r의 **오른쪽 서브 트리** 중 **최소 원소 노드(Successor, s)**를 찾습니다.
            
        2. s의 키 값을 r의 위치로 복사하거나 노드를 대체합니다.
            
        3. 기존 s의 위치에서 s를 삭제합니다. (이때 s는 왼쪽 자식이 없으므로 Case 1 혹은 Case 2의 규칙을 따릅니다) .
            

---

### 3. 레드 블랙 트리 (Red-Black Tree)

이진 검색 트리의 편향 문제를 해결하기 위해 균형을 유지하는 트리입니다.

#### 3.1. 5가지 필수 속성 (Properties)

1. 각 노드는 **Red** 또는 **Black** 색상을 가집니다.
    
2. **루트 노드**는 반드시 **Black**입니다.
    
3. 모든 **리프 노드(NIL)**는 **Black**입니다.
    
4. **Red** 노드의 자식은 반드시 **Black**이어야 합니다 (No Double Red).
    
5. 루트에서 임의의 리프 노드에 이르는 모든 경로에는 **동일한 개수의 Black 노드**가 존재해야 합니다 (Black Height 균형).
    

#### 3.2. 삽입 알고리즘 (Insertion Cases)

새 노드(x)는 항상 **Red**로 삽입합니다. 이후 규칙 위반(Double Red 등)을 해결합니다. 부모를 p, 조부모를 p2, 삼촌(부모의 형제)을 s라고 할 때:

- **Case 1: 삼촌(s)이 Red인 경우**
    
    - **해결:** p와 s를 Black으로, p2를 Red로 색변환(Recoloring)합니다. 문제가 p2 상위로 전파될 수 있습니다.
        
- **Case 2: 삼촌(s)이 Black인 경우**
    
    - **Case 2-1 (꺾인 상태):** x가 p의 오른쪽 자식이면, p를 중심으로 **왼쪽 회전**하여 Case 2-2 형태로 만듭니다.
        
    - **Case 2-2 (직선 상태):** x가 p의 왼쪽 자식이면, p2를 중심으로 **오른쪽 회전**하고 색상을 변경하여 균형을 맞춥니다.
        

#### 3.3. 삭제 알고리즘 (Deletion Cases)

삭제되는 노드가 Red이면 속성을 위반하지 않지만, **Black**이면 Black Depth가 변화하여 복잡한 복구 과정이 필요합니다. 삭제된 노드의 자식 위치(x)를 기준으로 형제 노드(s)와 조카 노드들의 색상에 따라 케이스를 분류합니다.

- **Case 1: 부모(p)가 Red인 경우**
    
    - s, l(왼쪽 조카), r(오른쪽 조카)의 색상 조합에 따라 회전 및 색상 변경을 수행합니다.
        
- **Case 2: 부모(p)가 Black인 경우**
    
    - **Case 2-4 (s가 Red):** 회전을 통해 s를 Black으로 만드는 상황으로 변환합니다.
        
    - 기타 조카 노드들의 색상에 따라 재귀적인 수정 혹은 종료 조건에 도달합니다 .
        

---

### 4. B-트리 (B-Tree)

디스크 접근 횟수를 줄이기 위해 고안된 **다진 검색 트리(Multi-way Search Tree)**입니다.

#### 4.1. 구조 및 특성

- **노드 구조:** (키, 페이지 번호) 쌍으로 구성되며, 디스크의 블록(페이지) 단위와 일치시킵니다.
    
- **키의 개수:** 루트를 제외한 모든 노드는 ⌈k/2⌉∼k 개의 키를 가집니다.
    
- **균형:** 모든 리프 노드는 같은 깊이(Depth)를 가집니다.
    

#### 4.2. 삽입 알고리즘

1. 키를 삽입할 리프 노드 r을 찾습니다.
    
2. **여유 있음:** r에 키를 순서대로 삽입하고 종료합니다.
    
3. **오버플로우 (Overflow):** r에 공간이 없으면 분할(Split)합니다.
    
    - 노드를 2개로 분리하고, **가운데 키(Median Key)**를 부모 노드로 올립니다.
        
    - 부모 노드에서도 오버플로우 발생 시 재귀적으로 위로 전파됩니다.
        

#### 4.3. 삭제 알고리즘

1. 삭제할 키 x를 찾습니다. x가 내부 노드에 있다면, 후행 키(Successor)와 맞바꾼 후 리프 노드에서 삭제합니다.
    
2. **언더플로우 (Underflow):** 삭제 후 키의 개수가 최소 조건 미만일 때 발생합니다.
    
    - **재분배 (Redistribution):** 형제 노드에 여유가 있다면 키를 하나 빌려오고(부모를 거쳐서 이동), 부모 키를 조정합니다.
        
    - **병합 (Merge):** 형제 노드도 여유가 없다면, 형제 노드와 병합하고 부모 노드에서 키 하나를 내려받습니다.
        

---

### 5. 다차원 검색 트리 (Multi-dimensional Search Tree)

검색 키가 두 개 이상의 필드로 이루어진 경우(예: 위도, 경도) 사용합니다.

#### 5.1. KD-트리 (KD-Tree)

- **원리:** 트리의 각 레벨(깊이)마다 비교하는 차원(필드)을 번갈아 가며 사용합니다 (예: 레벨 0은 x축, 레벨 1은 y축 비교).
    
- **특징:** k개의 필드를 사용하면 k 레벨마다 비교 필드가 일치합니다.
    

#### 5.2. KDB-트리 (KDB-Tree)

- **개념:** KD-트리의 다차원 분할 특성과 B-트리의 페이징/균형 특성을 결합했습니다.
    
- **노드 종류:**
    
    - **영역 노드 (Region Node):** 내부 노드로서 (영역, 페이지 번호) 쌍을 저장합니다.
        
    - **키 노드 (Key Node):** 리프 노드로서 실제 (키, 페이지 번호)를 저장합니다.
        

#### 5.3. R-트리 (R-Tree)

- **개념:** B-트리를 다차원 도형(점, 선, 면 등) 저장이 가능하도록 확장한 구조입니다.
    
- **MBR (Minimum Bounding Rectangle):** 도형을 포함하는 최소 외접 사각형을 사용하여 포함 관계를 표현합니다.
    
- **구조:** 루트를 제외한 내부 노드는 ⌈k/2⌉∼k 개의 영역을 가지며, 모든 레코드는 리프 노드에서만 가리킵니다.
    

#### 5.4. 그리드 파일 (Grid File)

- **특징:** 트리가 아닌 배열 기반 구조입니다.
    
- **구조:** 공간을 서로 배타적인 격자(Grid) 영역으로 나누고, 해당 영역의 레코드들을 모아 저장합니다.
    
- **관리:** 일차 스케일링 배열과 그리드 배열을 사용하여 키 값 위치를 직접 계산합니다.