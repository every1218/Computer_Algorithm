# Ch.7 해시 테이블 (Hashing)

## 1. 저장/검색의 복잡도와 해시 테이블의 도입 배경
데이터 저장 및 검색 알고리즘의 효율성을 비교하면 다음과 같습니다.

* **배열:** $O(n)$
* **이진 검색 트리:** 최악의 경우 $O(n)$, 평균 $O(\log n)$
* **균형 잡힌 이진 검색 트리 (예: 레드 블랙 트리):** 최악의 경우에도 $O(\log n)$ 보장
* **B-트리:** 최악의 경우 $O(\log n)$ (균형 트리보다 상수 인자가 작음)
* **해시 테이블:** **평균 $O(1)$ (상수 시간)**

> **도입 배경:** $O(\log n)$도 빠르지만 데이터 수($n$)가 커지면 시간도 증가합니다. 데이터 수와 무관하게 항상 상수 시간이 소요되는 방법을 찾기 위해 고안되었습니다.

---

## 2. 해시 테이블의 개념 및 구조
### 2.1 정의 및 특징
* **정의:** 원소의 값(Key)에 의해 저장될 자리(Address)가 결정되는 자료구조.
* **장점:** 평균 상수 시간에 삽입, 삭제, 검색이 가능하여 매우 빠른 응답이 필요한 응용(예: 119 호출 정보, 주민등록 시스템)에 유용합니다.
* **단점:** 순서 기반이 아니므로 최소/최대 원소 찾기와 같은 작업은 지원하지 않습니다.

### 2.2 구조 및 주소 계산
* **구성:** 검색 키(Key) $\rightarrow$ **해시 함수(주소 계산)** $\rightarrow$ 테이블 인덱스($0$ ~ $n-1$).
* **데이터 흐름 예시 (크기 13인 테이블):**
    * 입력값 `25, 13, 16, 15, 7`이 있을 때, 해시 함수를 통해 특정 인덱스에 매핑됩니다.
    * 예: 25 $\rightarrow$ 인덱스 12, 13 $\rightarrow$ 인덱스 0, 16 $\rightarrow$ 인덱스 3.

---

## 3. 해시 함수 (Hash Function)
해시 함수는 입력 원소를 해시 테이블에 고루 분산시켜야 하며 계산이 간단해야 합니다.

### 3.1 나누기 방법 (Division Method)
* **원리:** 해시 테이블 크기($m$)로 나눈 나머지를 주소로 사용합니다. 큰 수의 범위를 테이블 크기 내로 수축시킵니다.
* **수식:** $$h(x) = x \pmod m$$
* **참고:** $m$은 해시 테이블의 크기입니다.

### 3.2 곱하기 방법 (Multiplication Method)
* **원리:** 입력값을 0과 1 사이의 소수로 대응시킨 후, 테이블 크기 $m$을 곱하여 인덱스로 팽창시킵니다.
* **수식:** $$h(x) = \lfloor m(xA \pmod 1) \rfloor$$
    * $A$: $0 < A < 1$인 상수.
    * $xA \pmod 1$: $x$에 $A$를 곱한 값의 소수 부분 ($x \times A$의 정수부를 버린 값).
* **특징:** $m$을 굳이 소수로 잡을 필요가 없으며 보통 $2^l$로 잡습니다.
* **작동 과정:**
    1. 키 $x$에 $A$를 곱합니다.
    2. 나온 값에서 정수부를 제외한 **소수부**만 취합니다.
    3. 이 소수부에 $m$을 곱해 확장한 뒤, 그 결과의 **정수부**를 최종 인덱스로 사용합니다.

---

## 4. 충돌 (Collision) 및 해결 방법
**충돌**이란 해시 테이블의 한 주소를 놓고 두 개 이상의 원소가 자리를 다투는 현상을 말합니다.

### 4.1 체이닝 (Chaining)
* **개념:** 같은 주소로 해싱되는 원소들을 모두 하나의 **연결 리스트(Linked List)**에 매달아 관리합니다.
* **구조:**
    * `table[0]`: 39 $\rightarrow$ 13 (인덱스 0에 두 원소가 연결됨)
    * `table[3]`: 94 $\rightarrow$ 3 $\rightarrow$ 42 $\rightarrow$ 55 (인덱스 3에 네 원소가 연결됨)
    * 충돌이 발생하면 해당 인덱스의 리스트 맨 앞에 새 원소를 추가하거나 뒤에 연결합니다.
* **알고리즘 (작업 흐름):**
    * **삽입 (`chainedHashInsert`):** 리스트 $T[h(x)]$의 맨 앞에 $x$를 삽입합니다.
    * **검색 (`chainedHashSearch`):** 리스트 $T[h(x)]$를 순회하며 $x$를 찾습니다.
    * **삭제 (`chainedHashDelete`):** 리스트 $T[h(x)]$에서 $x$ 노드를 찾아 삭제합니다.

### 4.2 개방 주소 방법 (Open Addressing)
* **개념:** 충돌 시 빈자리가 생길 때까지 해시값을 계속 만들어 테이블 공간 내에서 해결합니다.
* **조사 순서:** $h_0(x), h_1(x), h_2(x), \dots$ 순으로 빈칸을 찾습니다.

#### A. 선형 조사 (Linear Probing)
* **방식:** 충돌이 일어나면 **바로 뒷자리(+1)**를 확인합니다.
* **수식:** $$h_i(x) = (h(x) + i) \pmod m$$ ($i=0, 1, 2, \dots$).
* **문제점:** **1차 군집(Primary Clustering)** 발생. 특정 영역에 원소가 몰리면 성능이 치명적으로 저하됩니다.

#### B. 이차원 조사 (Quadratic Probing)
* **방식:** 보폭을 **이차 함수**로 넓혀가며 빈자리를 찾습니다.
* **수식:** $$h_i(x) = (h(x) + c_1i^2 + c_2i) \pmod m$$.
* **장점:** 1차 군집은 피할 수 있으나, 동일한 초기 해시값을 가진 원소들이 같은 궤적을 그리는 **2차 군집(Secondary Clustering)**이 발생할 수 있습니다.

#### C. 더블 해싱 (Double Hashing)
* **방식:** 2개의 해시 함수를 사용하여 보폭과 초기 위치를 결정합니다.
* **수식:** $$h_i(x) = (h(x) + i \cdot f(x)) \pmod m$$.
    * $h(x)$: 초기 위치 결정.
    * $f(x)$: 이동 보폭 결정 ($i$가 증가함에 따라 $f(x)$만큼 건너뜀).
* **효과:** 2차 군집 문제를 해결하여 데이터가 골고루 분산됩니다.

---

## 5. 개방 주소 방법의 알고리즘 상세
### 5.1 삽입 (`hashInsert`)
1. **초기화:** 조사 횟수 $i = 0$.
2. **반복 (Loop):** $i$가 테이블 크기 $m$이 될 때까지 반복합니다.
    * 인덱스 $j \leftarrow h_i(x)$ 계산.
    * **조건:** $T[j]$가 `NIL`(비어있음)이거나 `DELETED`(삭제됨) 상태이면:
        * $T[j] \leftarrow x$ 저장 후 $j$ 반환 (종료).
    * **충돌 시:** $i$를 1 증가시키고 다음 위치를 조사합니다.
3. **오버플로우:** 반복문 종료 시 "테이블 오버플로우" 에러를 발생시킵니다.

### 5.2 검색 (`hashSearch`)
1. **초기화:** $i = 0$.
2. **반복 (Loop):** $T[j]$가 `NIL`이거나 $i=m$이 될 때까지 반복합니다.
    * 인덱스 $j \leftarrow h_i(x)$ 계산.
    * **발견 시:** $T[j] = x$이면 $j$ 반환 (종료).
    * **미발견 시:** $i$를 1 증가시키고 계속 조사합니다.
3. **실패:** 반복문 종료 후 `NIL`을 반환합니다.

### 5.3 삭제 처리의 중요성
* 개방 주소법에서 단순히 원소를 비우면(`NIL`), 검색 시 해당 위치에서 탐색이 끊기는 문제가 발생합니다.
* **해결:** 삭제된 자리에 **`DELETED`** 표시를 남겨, 검색 과정이 해당 위치를 건너뛰고 계속 진행되도록 해야 합니다.

---

## 6. 성능 분석 (검색 시간)
적재율(Load Factor) $\alpha = \frac{n}{m}$ ($n$: 원소 수, $m$: 테이블 크기)일 때의 성능 분석입니다.

### 6.1 체이닝 (Chaining)
* **실패하는 검색:** 기대 조사 횟수 $= \alpha$.
* **성공하는 검색:** 기대 조사 횟수 $= 1 + \frac{\alpha}{2} - \frac{\alpha}{2n} \approx 1 + \frac{\alpha}{2}$.

### 6.2 개방 주소 방법 (Open Addressing) ($\alpha < 1$)
* **실패하는 검색:** 최대 $\frac{1}{1-\alpha}$.
* **성공하는 검색:** 최대 $\frac{1}{\alpha} \ln \frac{1}{1-\alpha}$.
    * (가정: 해시 함수가 이상적인 특성을 만족한다고 전제)

## 7. 해시 테이블의 재조정 (Resizing)
* 적재율 $\alpha$가 높아지면 충돌이 빈번해져 효율이 떨어집니다.
* **해결책:** 임계값을 설정해두고, 적재율이 이에 도달하면 테이블 크기를 **두 배**로 늘린 뒤 모든 원소를 **다시 해싱(Re-hashing)**하여 저장합니다.